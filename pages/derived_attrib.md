# Quick derived attributes in Python attrs classes

In a [previous post](attrs_dataclasses_results.md) I described how I use the Python ``attrs`` package
to wrap analytics results. 
At the end I mentioned derived attributes, and this is what I want to describe here.


## Why

One of my primary uses for derived attributes is string formatting of numerical analytics results.
Let's use a similar example class as in the [previous post](attrs_dataclasses_results.md), returning
a query result for post statistics of a user:
```python
import attr

@attr.s
class UserTotalPosts:
    user_id = attr.ib()  # type: int
    nick = attr.ib()  # type: str
    total_posts = attr.ib()  # type: int
    fraction_liked = attr.ib()  # type: float
```

For showing those data in a web interface, I want a nice string representation of ``total_posts``,
with a narrow non-breaking space (unicode ``U+202F``) as thousands separator,
and of ``fraction_liked``, as rounded percentage.
Of course, I could do the string formatting in my view code, in the HTML template, or somewhere else.
However, for a query that is used in a bunch of different views, the data class itself seems to be a natural
place for creating the string representations.


## How

The `attrs` [package](https://pypi.org/project/attrs/) uses the concept 
of [factories](https://www.attrs.org/en/stable/api.html?highlight=factory#attr.Factory)
for defining default values.
The factory functions can be configured to take ``self``, the partly-initialized data class instance, as argument.
This way, you can initialize default values for attributes from other attribute values.

(Something similar can probably be done in Python 3.7+ ``dataclass`` objects via 
[post-init processing](https://docs.python.org/3.7/library/dataclasses.html#post-init-processing), but I haven't tried that myself.)

I have wrapped this way of initializing an attribute from other attributes into a function and called it 'derived attribute'.
Here is the function code:

```python
import attr

def derived_attrib(derived_from, generator, **attrib_params):
    """Build a derived attribute

    This attribute derives its default value from the attribute named <derived_from>. 
    The value is generated by passing the attribute value through <generator>. 
    These parameters are stored in the attribute metadata for later reference.

    Args:
        derived_from (str or List[str] or Tuple[str]): attribute name from which the current attribute derives its value
            or list of attribute names
        generator (callable):
            - for single value in derived_from: function taking one argument, an attribute value, and returning
                the value of the derived attribute
            - for multiple values in derived_from: function taking the respective attribute values, in the order
                as specified in derived_from, and returning the value of the derived attribute
        attrib_params: additional arguments, passed into attr.ib

    Returns:
        attr.Attribute: derived attribute
    """
    # always make derived_from iterable, to save some if statements below
    if isinstance(derived_from, str):
        derived_from = (derived_from,)
    
    # store details of derived attribute generation
    metadata = attrib_params.get("metadata", dict())
    metadata["DERIVED_FROM"] = derived_from
    metadata["GENERATOR"] = generator

    # define a function for generating the derived default value from the partially initialized object
    def derived_default(obj):
        return generator(*[getattr(obj, d) for d in derived_from])

    return attr.ib(
        metadata=metadata,
        default=attr.Factory(derived_default, takes_self=True),
        **attrib_params
    )
```


## An example

Let's extend our example class from above to use derived attributes for string formatting:
```python
@attr.s
class UserTotalPosts:
    user_id = attr.ib()  # type: int
    nick = attr.ib()  # type: str
    total_posts = attr.ib()  # type: int
    fraction_liked = attr.ib()  # type: float

    total_posts_str = derived_attrib(
        "total_posts", lambda i: "{:,d}".format(i).replace(",", "\u202F")
    )  # type: str

    fraction_liked_str = derived_attrib(
        "fraction_liked", lambda f: "{:.0f}%".format(f * 100)
    )  # type: str
```

Now, we instantiate an example object (note that we don't specify the ``..._str`` fields):
```python
r = UserTotalPosts(
    user_id=42,
    nick="Douglas",
    total_posts=1234567,
    fraction_liked=0.3141592,
)
``` 

Printing that shows that the formatted strings were automatically generated:
```python
print(r)
```
yields
```text
UserTotalPosts(user_id=42, nick='Douglas', total_posts=1234567, fraction_liked=0.3141592,
               total_posts_str='1\u202f234\u202f567', fraction_liked_str='31%')
```

We can also define more complicated derived attributes that are initialized from several fields.
For example, if we wanted to know the number of liked posts, i.e. the total number of posts times the liked fraction,
we could add the following derived attribute to the class:
```python
    liked_posts = derived_attrib(
        ["total_posts", "fraction_liked"], lambda i, f: i * f
    )  # type: float
```

Then, initializing and printing an example instance as above computes the number of liked posts:
```text
UserTotalPosts(user_id=42, nick='Douglas', total_posts=1234567, fraction_liked=0.3141592, 
               total_posts_str='1\u202f234\u202f567', fraction_liked_str='31%', 
               liked_posts=387850.58106640005)
```

You are bound to get into trouble when you try to do too complicated data transformations this way.
But for string formatting and related tasks I find this quite useful.




<<< Go back to the [table of contents](../README.md) || Follow on [twitter](https://twitter.com/EberhardHansis) || Opinions are mine, not necessarily those of [Vebeto GmbH](https://www.vebeto.de)